#include "prototypes.h"

using namespace std;

const int dictSize = 9; // размер словарного запаса программы
library dictionary[dictSize]{ "help", "showAll", "searchI", // сам словарный запас программы
"searchN", "add", "delete", "redact", "move", "shut" };

int main()
{
    // Часть 1. Начало работы в программе. Авторизация для администраторов
    string dialog; // строка, использующаяся во всей программе, нужная, чтобы получать текстовый ввод пользователя
    cout << " Greetings in the storageManage application! " << endl
         << " Enter \"start\" to run the program: _____\b\b\b\b\b";
    getline(cin, dialog);
    while (dialog != "start") // проверка на правильность ввода
    {
        cout << " Wrong command. Try again: _____\b\b\b\b\b";
        getline(cin, dialog); // ввод строчно-ориентированный нужен здесь для того,
    } //  чтобы при вводе нескольких слов через пробел сообщение не выводилось несколько раз.
    cout << " Before start working, please, enter, who are you\n \"admin\" - administrator" << endl
        << " \"visit\" - visitor\n Your choice: _____\b\b\b\b\b";
    getline(cin, dialog);
    string username; // строка, хранящая имя админа. Если пользователь не админ, то значение строки всегда будет "guest".
    bool isAdmin = false; // права администратора
    if (oneFromTwoCh(dialog, "admin", "visit")) // "oneFromTwoCh" - функция для определения выбранного варианта из двух возможных
    {
        cout << " Enter your special admin-key: ______\b\b\b\b\b\b";
        getline(cin, dialog);
        username = adminAuthorization(dialog); // "adminAuthorization" - функция для выполнения авторизации администратора в программе
    } 
    else
        username = "guest";
    if (username != "guest")
        isAdmin = true;
    cout << " User " << username << " has started the work." << endl;
    int result = 0; // переменная, значения которой являются режимами работы программы.
    instructions(result, isAdmin); // "instructions" - функция для вывода инструкций в зависимости от режима работы программы и наличия прав админа
    getline(cin, dialog);
    while (result != 8) // режим 8 - завершение работы программы
    {
        result = commRecognition(dialog, dictionary, dictSize); // "commRecognition" - функция для распознания введеной пользователем команды
        instructions(result, isAdmin);
        switch (result)
        {
        case 10:
            getline(cin, dialog);
            break;
        case 0:
            getline(cin, dialog);
            break;
        case 1:
            // Функция для вывода информации из всех файлов.
            /* Принцип работы:
            * Программа в папке с текстовыми файлами по очереди сверху вниз открывает каждый файл,
            * читает в нем строку и выводит ее в консоль. */
            break;
        case 2:
            // Функция для поиска по индексу.
            /* Принцип работы
            * Программа так же по очереди построчно читает каждый файл,
            * затем инвертирует строку, читает первое слово и снова его инвертирует
            * (то есть читает индекс, который стоит в конце строки). Затем программа
            * сверяет полученный индекс с входными данными и если индекс совпадает,
            * то инвертирует всю прочитанную строку и выводит в консоль.
            */
            break;
        case 3:
            // Функция для поиска по имени.
            /* Принцип работы:
            * Прорамма в каждом по очереди файле читает сперва первое слово
            * (то есть читает имя товара, находящееся в самом начале каждой строки),
            * затем сверяет его с входными данными и если слова совпадают, выводит
            * сперва это слово, а потом дочитывает остальную строку и тоже выводит в консоль.
            */
            break;
        case 4:
            // Функция для добавления новой информации.
            /* Принцип работы:
            * Программа запрашивает информацию о товаре через пробел
            * по образцу имя->стоимость->количество, затем программа
            * запрашивает номер склада, а потом переводит номер склада в имя файла
            * и добавляет новую строчку в конец файла и присваивает новому товару
            * его персональный индекс.
            */
            break;
        case 5:
            // Функция для удаления информации
            /* Принцип работы:
            * Программа просит сперва найти интересующую строку по имени или индексу.
            * Если этот шаг уже выполнен, то программа стирает строку, а строки, идущие после,
            * должны перезаписаться на позицию выше.
            */
            break;
        case 6:
            // Функция для редактирования информации
            /* Принцип работы:
            * Программа по-прежнему предлагает найти интересующую строку по имени/индексу.
            * Если этот шаг уже выполнен, то программа запрашивает изменяемый параметр.
            * Каждый параметр в программе имеет свой номер, и после ввода параметра программа
            * переводит его в число. Полученное число - кол-во слов, которые нужно пропустить до того,
            * как программа достигнет позиции с нужным параметром. После запрашивается новое значение
            * для параметра и значение параметра обновляется этим словом.
            */
            break;
        case 7:
            // Функция для перемещения товара из одного склада на другой
            /* Принцип работы:
            * Программа запрашивает найти нужную строку, затем программа просит ввести
            * номер склада, на который нужно переместить товар. Строку программа записывает в спец.буфер.
            * Файлы являются складами и именуются по типу AAAAA.
            * Каждая буква имеет свой ACSII-код. Номер склада, вводимый пользователем,
            * прибавляется к ASCII-значению последней буквы. Как только значение буквы становится равным 90
            * (то есть буква теперь не А, а Z), прибавляется единица к предыдущей букве,
            * а последней буквой вновь становится A. Таким образом, автоматически
            * изменяется адрес подключаемого файла. После изменения адреса файла переносимая информация
            * из спец.буфера записывается в конец открытого файла.
            */
            break;
        }
    }
}